<!DOCTYPE html>
<html lang="en">
<head>
    <title>axkralj990</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="AK_stylesheet.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Orbitron">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto Condensed">
</head>
<body>

	<div id="myNav" class="projects"></div>

	<div class="container" style="margin-top: 70px;">

    <h1>I<sup>2</sup>C</h1>

<h3>Introduction</h3>
<p><strong>I<sup>2</sup>C</strong> (pronounced I-two-C and most of the time also written as I2C as well) is a very popular communication protocol in the world of microcontrollers. It's advantage is that it allows communication between multiple devices by using only two wires, <strong>SDA (Serial Data Line)</strong> and <strong>SCL (Serial Clock Line)</strong>, unlike USART or SPI where every pair of devices needs its own set of wires. The protocol was invented by Phillips Semiconductors in 1982. The first time I encountered I2C was when I wanted to measure the orientation in space with my Arduino. For that purpose I bought an MPU6050 inertial measurement unit (IMU) that required I2C to talk to it. At first I was really confused since I had no experience with digital communication protocols except some basic understanding of USART from using Arduino Serial library. The first time I looked at an example code for reading accelerometer and gyroscope data from the MPU6050, the example code scared the hell out of me with of a bunch of hexadecimal register addresses. In this tutorial I will try to do my best to explain the principle of the I2C protocol and show an example using an Arduino, standalone ATMega328P chip and Raspberry Pi. I will start with an Arduino Uno and add examples with other devices later. For all the examples I will use the MPU6050, but you may use whichever device you desire. Sometimes I will refer to Arduino and the standalone ATmega328P chip, simply as ATmega328P, since this is also the microcontroller that Arduino uses, but I will provide an example on how to use I2C on a standalone ATmega328P chip in plain C as well. Just for the side note, in terms of legal issues, I<sup>2</sup>C can be freely implemented on any commercial device, but in order to use the name I<sup>2</sup>C on the product, you have to pay, so most of the products use a different name. For instance Atmel uses "Two-wire interface" (TWI) on they chips (ATmega328P).</p>

<h3>The Principle</h3>

<p>To explain how the protocol works I will use an example of three human slaves, where each one monitors a different sensor and reports the reading to the one of the two masters when they request it. Slaves and masters use walkie-talkies to talk to each other. Image below shows the three slaves and two masters.</p>

<img src="images/master_slave.png" class="report-figure" style="padding-bottom: 20px;">

<p>Slave A monitors a humidity sensor, slave B a thermometer and slave C a barometer. Masters 1 or 2 can ask the slaves for readings whenever they want. In smaller microcontroller projects, you will most likely use a single master, but in order to explain the full functionality of I2C, I'm using two masters.</p> 

<p>Since there are three different slaves, each one of them has a name (an address) by which the master is going to get their attention. To keep it simple I will just name them A, B an C, as depicted on the image. They agreed in advance that to get the data from the slaves, a master has to first remotely ring a bell at the site where the slaves are, get the desired slave's attention by calling the slave's name and then tell the slave in what units the data should be reported. Once the master gets a pencil and a paper to write down the measurement from the slave he/she transmits the name of the slave again, which means that the slave should report the measurement. Once the measurement is written down, the master rings the bell twice to mark the end of the conversation. To make sure that a certain slave is present (better be) and that the instruction was heard, the receiver <strong>acknowledges</strong> that the instruction was received. If the master is happy with the received message, he/she transmits "enough", to indicate that this was all that was needed. I will call this "enough" as not-acknowledged (sounds weird, but you will see later why I call it like that). In order for the master 1 to receive the temperature in Fahrenheit from the slave B, the conversation would go as following:</p>

<table class="table" style="width: 80%; margin: 0 auto;">
    <thead>
      <tr>
        <th>Message Type</th>
        <th>Person</th>
        <th>Message</th>
      </tr>
    </thead>
    <tbody>     
      <tr class="success">
        <td>Start Condition</td>
        <td>Master 1:</td>
        <td><i class="fa fa-bell" aria-hidden="true"></i></td>
      </tr>
      <tr class="success">
        <td>Slave Address</td>
        <td>Master 1:</td>
        <td>"slave B listen"</td>
      </tr>
      <tr class="info">
        <td>Slave's Acknowledgment</td>
        <td>Slave B:</td>
        <td>"roger"</td>
      </tr>
      <tr class="success">
        <td>Slave Instruction</td>
        <td>Master 1:</td>
        <td>"report temperature in F"</td>
      </tr>
      <tr class="info">
        <td>Slave's Acknowledgment</td>
        <td>Slave B:</td>
        <td>"roger"</td>
      </tr>
      <tr class="success">
        <td>Slave Address</td>
        <td>Master 1:</td>
        <td>"slave B go ahead"</td>
      </tr>
      <tr class="info">
        <td>Slave's Acknowledgment</td>
        <td>Slave B:</td>
        <td>"roger"</td>
      </tr>
      <tr class="info">
        <td>Slave Report</td>
        <td>Slave B:</td>
        <td>"95"</td>
      </tr>
      <tr class="success">
        <td>Master's Not-acknowledgment</td>
        <td>Master 1:</td>
        <td>"enough"</td>
      </tr>
      <tr class="success">
        <td>Stop Condition</td>
        <td>Master 1:</td>
        <td><i class="fa fa-bell" aria-hidden="true"></i><i class="fa fa-bell" aria-hidden="true"></i></td>
      </tr>
    </tbody>
  </table>

<p style="padding-top: 20px">Just to understand another important concept let's assume that the master 1 wants to know the pressure in psi and MPa from the slave C. They also agreed in advance that whenever the master acknowledges the reception by "roger", the slave then just transmits the measurement in another unit right after. Slave C keeps track of pressure measurements in psi, MPa, atm and torr, so if the master received the measurement in psi, he/she acknowledges the message by "roger", to let the slave know to send the pressure in kPa as well. The slave keeps sending the measurement until the master "not-acknowledges" the reception by "enough" or until the slave has no more measurements to send. The conversation for receiving pressure measurements in psi and kPa would go like this:</p>

<table class="table" style="width: 80%; margin: 0 auto;">
    <thead>
      <tr>
        <th>Message Type</th>
        <th>Person</th>
        <th>Message</th>
      </tr>
    </thead>
    <tbody>     
      <tr class="success">
        <td>Start Condition</td>
        <td>Master 1:</td>
        <td><i class="fa fa-bell" aria-hidden="true"></i></td>
      </tr>
      <tr class="success">
        <td>Slave Address</td>
        <td>Master 1:</td>
        <td>"slave C listen"</td>
      </tr>
      <tr class="info">
        <td>Slave's Acknowledgment</td>
        <td>Slave C:</td>
        <td>"roger"</td>
      </tr>
      <tr class="success">
        <td>Slave Instruction</td>
        <td>Master 1:</td>
        <td>"report pressure in psi"</td>
      </tr>
      <tr class="info">
        <td>Slave's Acknowledgment</td>
        <td>Slave C:</td>
        <td>"roger"</td>
      </tr>
      <tr class="success">
        <td>Slave Address</td>
        <td>Master 1:</td>
        <td>"slave C go ahead"</td>
      </tr>
      <tr class="info">
        <td>Slave's Acknowledgment</td>
        <td>Slave C:</td>
        <td>"roger"</td>
      </tr>
      <tr class="info">
        <td>Slave Report</td>
        <td>Slave C:</td>
        <td>"14.7"</td>
      </tr>
      <tr class="success">
        <td>Master's Acknowledgment</td>
        <td>Master 1:</td>
        <td>"roger"</td>
      </tr>
      <tr class="info">
        <td>Slave Report</td>
        <td>Slave C:</td>
        <td>"1013.5"</td>
      </tr>
      <tr class="success">
        <td>Master's Not-acknowledgment</td>
        <td>Master 1:</td>
        <td>"enough"</td>
      </tr>
      <tr class="success">
        <td>Stop Condition</td>
        <td>Master 1:</td>
        <td><i class="fa fa-bell" aria-hidden="true"></i><i class="fa fa-bell" aria-hidden="true"></i></td>
      </tr>
    </tbody>
  </table>

<p style="padding-top: 20px">This acknowledgment, not-acknowledgment agreement would prove more useful if there was only one slave who was measuring all the different sensors at once. In that case the master would just tell the slave to report whatever measurement was the first on the list and keep acknowledging until all the required measurements were received. The communications seems quite complicated and redundant, but this protocol is not really intended for humans, but digital devices instead. By saying that they know something in <strong>advance</strong>", it is implied that these are the <strong>rules</strong> of the protocol. Before going into the world of digital devices, let's go over some of the specifications and prerequisites.</p>

<h3>The Basics</h3>

<p>In order to follow the tutorial you should be familiar with:</p>
<ul>
  <li>basic electronics</li>
  <li>basic C (or Arduino dialect)</li>
  <li>the difference between binary, decimal, hexadecimal, ...</li>
  <li>what registers are (at least know that a register is a storage area where data or instructions are stored, in ATmega328P they are 8-bits long)
</li>
</ul>

<p>The devices communicating via I2C are all connected to the same set of wires, SDA (Serial Data Line) and SCL (Serial Clock Line), where all the data transfers takes place. The two wires constitute the <strong>I2C bus</strong>. As shown in the example above, I2C is a multi-master, multi-slave protocol, which means that a system of nodes (devices) can have multiple master devices and multiple slave devices. To understand what this means you need to understand what each one of them does. In a few words:</p>

<ul>
	<li>Master Device: generates the clock and initializes the communication with a slave device</li>
	<li>Slave Device: receives the clock and responds when addressed by the master.</li>
</ul>
<p>Microcontrollers such as the Arduino (ATmega328P) can be configured to act as a master or a slave device, whereas simpler sensor devices usually support only the slave mode.</p>

<blockquote><small>One thing to keep in mind when using multiple masters is that they cannot communicate with each other, but they have to listen to I2C bus if anyone else is transmitting before requesting data from the slaves, so they don't request it at the same time, since the slaves would not understand what masters want if they request something at the same time. This also applies to the regular conversation between people. If you talked to an audience, everyone who listened would understand what you are saying (assuming you talked loud and clear in a language everyone understood). But if everyone in the audience tried to tell you something at the same time, you would just hear some jibber jabber. If two or more master devices would transmit a packet to slaves at the same time, the packets would <em>collide</em>, so in case of a multi-master I2C setup, some sort of packet collision aviodance mechanism has to be implemented. As I wrote before, this only applies if you have a project consisting of multiple master devices, otherwise do not worry about this now.</small></blockquote>

<h4>SCL and SDA</h4>

<p>SDA is where the data, the payload, is transmitted between the devices.</p>

<p>SCL is where the master sends the generated clock signal that the slave devices receive. With this said, a shared clock between the master and slave devices makes I2C a <strong>synchronous protocol</strong>, in contrast of USART, which is <strong>asynchronous</strong>. In asynchronous protocols the two devices talking to each other need to know in advance the rate at which they will transfer bits (baudrate).</p>

<p>The clock that the master generates defines the rate at which the data is transfered. I2C supports various clock speeds, but simple devices commonly used in microcontroller projects support the original 100 kHz mode or the 400 kHz fast-mode. The fastest supported mode for I2C right now is 5 GHz Ultra Fast-mode.</p>

<h4>Addressing</h4>

<p>The number of devices that I2C can communicate with are defined by the number of bits each device's address consists of. I2C devices can have 7 or 10 bit addresses. In theory, the largest number that a 7-bit address can be is (1111111)<sub>2</sub> or (127)<sub>10</sub>, which defines the maximum number of devices connected to the same I2C bus. Since there are some addresses that are reserved and cannot be used for addressing, the maximum number of devices with 7-bit addresses is (112)<sub>10</sub>. (I am using the parentheses with a subscript to indicate the base of the number, so 2 for binary and 10 for decimal and 16 for hexadecimal.) The maximum number of devices is also limited at the physical layer by the total bus capacitance.</p>

<p>I2C addresses as well as any other memory address (registers, etc.) are by convention expressed in hexadecimal. Hexadecimal numbers are much more convenient then binary, since in binary the addresses would become very long, which would be very hard to remember and prone to mistakes. The conversion between hexadecimal and binary is much easier then between decimal and binary. Sometimes I will use the C-language syntax to indicate the base of the numbers, where decimal numbers are depicted simply as the number itself, binary numbers have 0b prefix (ex: 0b1010 = 10) and hexadecimals have 0x prefix (ex: 0xA = 0b1010 = 10).</p>

<h3>Example with Digital Devices</h3>

<p>To give the just explained information more sense, let's consider a real I2C example shown below.</p>

<img src="images/master_slave_real.png" class="report-figure" style="width: 95%">

<p>This setup uses two masters, one is an Arduino Uno used to control something and the other one is a Raspberry Pi used for storing the data to a remote database. The slaves are two MPU6050 IMUs, placed on two different spots on, for example, a spaceship.</p>

<p>As we switched from people to digital devices, the first thing to do is to wire them properly. As you can see on the image above, both I2C wires, SDA and SCL are connected to the same voltage source by 2 pull-up resistors. The reason the pull-up resistors are used is that the I2C lines are open-drain (or open-collector in TTL), which means that the signal can be pulled to low, but not to high. For projects with Arduino, Raspberry Pi and other similar devices, the source is usually 3.3 V or 5 V. The selection of pull-up resistors is a bit more complicated, since an optimal resistance depends on the length of the wires and the number of connected devices to the bus. Sparkfun recommends to start with 4.7 k&#8486; resistors and work down if needed. All of the devices have to be to be connected to a common ground, this is very important. Before getting all frustrated by selecting proper pull-up resistors make sure that the devices you are going to use don't implement them already, for instance MPU6050 has both lines connected to high with 4.7 k&#8486; resistors. If all the devices are very close to each other that should usually work most of the time, but if you intend to use longer wires for I2C, you might have to try different pull-up resistors. Also keep in mind that longer wires are more prone for errors, so if there is much more environmental noise, they should be kept as short as possible.</p>

<p>Now that all is hooked up, let's go into the basics of the protocol. The clock signal on the SCL is generated by the master devices when it initiates the communication. When no communication is taking place, the SCL is constantly pulled to high. A very important rule of the protocol is that a signal on SDA can change only when the clock is low, except when the master assign the start and stop of the communication. Start and stop conditions consist of a change of state when the clock is high, they are defined as:</p>

<ul>
	<li>Start: SDA is pulled from high to low</li>
	<li>Stop: SDA is pulled low from high.</li>
</ul>

<p>Right after the start condition is transmitted by the master, other communication information follows. Devices decode whether the bit send is true or false, by checking if the voltage is high or low when the clock (SCL) is high. It's easier to explain this with a simple timing diagram as shown below: (For drawing timing diagrams I use <a href="http://wavedrom.com/" target="_blank">WaveDorm</a>.)</p>

<img src="images/I2C_timing.png" class="report-figure" style="width: 90%">

<p>In this example I will use devices with 7-bit addresses, slave A has the address (68)<sub>16</sub> and slave B the address (69)<sub>16</sub>. So in order to address the right slave, its address has to be sent in binary right after the start bit. So to address the (68)<sub>16</sub> MPU6050, (1101000)<sub>2</sub> has to be sent.</p>

<p>Just like the master had to tell the slave whether to listen or do report the data, the master device has to do the same, so the bit sent after the address is called the <strong>direction bit</strong> (READ/WRITE), where:</p>

<ul>
  <li>Read: 1 (low)</li>
  <li>Write: 0 (high)</li>
</ul>

<p>Sometimes the addresses are written as devices <strong>write</strong> and <strong>read address</strong>. Those addresses are just the 7-bit device's address with the direction bit appended. For the (68)<sub>16</sub> MPU6050 we could write read and write addresses as following:</p>

<ul>
  <li>Read Address: (11010001)<sub>2</sub> = (D1)<sub>16</sub></li>
  <li>Write Address: (11010000)<sub>2</sub> = (D0)<sub>16</sub></li>
</ul>

<p>When the slave is address and no errors occurred, the slave acknowledge the message. The acknowledge bit is depicted as <strong>ACK</strong> and not-acknowledge as <strong>NACK</strong>, where:</p>

<ul>
  <li>ACK: 0 (low)</li>
  <li>NACK: 1 (high)</li>
</ul>

<p>ACK and NACK bit is transmitted by the received device, whether this is a master or the slave, right after the 8-bit from the sender are received. NACK bit is used to let the sender know that enough information was received and that the communication is about to stop or whenever an error occurred, so it can be used for error checking. This also makes I2C suitable for noise environments.</p>

<p>To recap how the whole communication between a master and a slave goes, I will show it in a similar table I used in the second example, except here I will use an IMU for getting the 16-bit signed integer reading of the acceleration in X direction (the coordinate axis is draw on the accelerometer, this information doesn't really matter for now). Because only 8-bit number can be read from a device right now and because the IMU (as well as the ATmega328P) store the data in 8-bit registers, 16-bit numbers have to be store in two separate registers. The most significant 8 bits are stored at one location and the least significant 8-bit are stored at another location, most of the time they are in the next location from the most significant bit, so they can be read one after another. Here is the table:</p>

<table class="table" style="width: 80%; margin: 0 auto;">
    <thead>
      <tr>
        <th>Message Type</th>
        <th>Device</th>
        <th>Verbal</th>
        <th>Digital</th>
      </tr>
    </thead>
    <tbody>     
      <tr class="success">
        <td>Start Condition</td>
        <td>Master 1:</td>
        <td><i class="fa fa-bell" aria-hidden="true"></i></td>
        <td>SDA <i class="fa fa-arrow-down" aria-hidden="true"></i></td>
      </tr>
      <tr class="success">
        <td>Slave Address</td>
        <td>Master 1:</td>
        <td>"slave C listen"</td>
        <td>(11010000)<sub>2</sub> <i class="fa fa-arrow-right" aria-hidden="true"></i> Slave Write Address</td>
      </tr>
      <tr class="info">
        <td>Slave's Acknowledgment</td>
        <td>Slave C:</td>
        <td>"roger"</td>
        <td>ACK <i class="fa fa-arrow-right" aria-hidden="true"></i> 0</td>
      </tr>
      <tr class="success">
        <td>Slave Instruction</td>
        <td>Master 1:</td>
        <td>"report X-accelerationX (High Byte)"</td>
        <td>(XXXXXXXX)<sub>2</sub> <i class="fa fa-arrow-right" aria-hidden="true"></i> Register to get the data from</td>
      </tr>
      <tr class="info">
        <td>Slave's Acknowledgment</td>
        <td>Slave C:</td>
        <td>"roger"</td>
        <td>ACK <i class="fa fa-arrow-right" aria-hidden="true"></i> 0</td>
      </tr>
      <tr class="success">
        <td>Slave Address</td>
        <td>Master 1:</td>
        <td>"slave C go ahead"</td>
        <td>(11010001)<sub>2</sub> <i class="fa fa-arrow-right" aria-hidden="true"></i> Slave Read Address</td>
      </tr>
      <tr class="info">
        <td>Slave's Acknowledgment</td>
        <td>Slave C:</td>
        <td>"roger"</td>
        <td>ACK <i class="fa fa-arrow-right" aria-hidden="true"></i> 0</td>
      </tr>
      <tr class="info">
        <td>Slave Report</td>
        <td>Slave C:</td>
        <td>"14.7"</td>
        <td>(XXXXXXXX)<sub>2</sub> <i class="fa fa-arrow-right" aria-hidden="true"></i> 8-bit data value</td>
      </tr>
      <tr class="success">
        <td>Master's Acknowledgment</td>
        <td>Master 1:</td>
        <td>"roger"</td>
        <td>ACK <i class="fa fa-arrow-right" aria-hidden="true"></i> 0</td>
      </tr>
      <tr class="info">
        <td>Slave Report</td>
        <td>Slave C:</td>
        <td>"1013.5"</td>
        <td>(XXXXXXXX)<sub>2</sub> <i class="fa fa-arrow-right" aria-hidden="true"></i> 8-bit data value</td>
      </tr>
      <tr class="success">
        <td>Master's Not-acknowledgment</td>
        <td>Master 1:</td>
        <td>"enough"</td>
        <td>NACK <i class="fa fa-arrow-right" aria-hidden="true"></i> 1</td>
      </tr>
      <tr class="success">
        <td>Stop Condition</td>
        <td>Master 1:</td>
        <td><i class="fa fa-bell" aria-hidden="true"></i><i class="fa fa-bell" aria-hidden="true"></i></td>
        <td>SDA <i class="fa fa-arrow-up" aria-hidden="true"></i></td>
      </tr>
    </tbody>
  </table>

<h3>Arduino Code Example</h3>

<p>For this example I will use the MPU6050 IMU as well, since this is a chip I work most often with and I think it's simple enough to use it for introductory I2C example. The MPU6050 operates on 3.3 V, but the board has a voltage regulator, so it will work by connecting it to 5 V as well. The schematic for this example is shown below:</p>

<img src="images/arduinoExample.png" class="report-figure" style="width: 50%; padding-top: 20px; padding-bottom: 20px;">

<p>The Vcc pin on the MPU6050 is connected to 5 V on Arduino. Grounds (GND) are connected together. SCL and SDA pins on the MPU6050 are connected to SCL and SDA on the Arduino, SCL is on pin A5 and SDA is on pin A4. AD0 pin on the MPU6050 is connected to ground, the AD0 pin is a device address select pin, since if connected to ground, MPU6050's address is (68)<sub>16</sub>, if connected to Vcc, its address is (69)<sub>16</sub>. This makes it possible to use two MPU6050s on the same I2C bus.</p>

<p>With the MPU6050 we can measure acceleration and angular rates in three axis (X, Y and Z), but for simplicity I will read only acceleration in Z direction from it. All of the measurements on the IMU are 16-bits longs, hence they are stored in two separate registers that have to be read from and combined into one 16-bit value on the Arduino.</p>

<p>In the example with ATmega328P I will go more into lower level details on how I2C works, but in this example with the Arduino Uno, I will keep it a bit simpler and use Arduino's "Wire.h" library that is written specifically for I2C communication. First I will show the code and then explain the I2C functions.</p>

<pre class=".pre-scrollable"><code>
#include&lt;Wire.h&gt;

#define MPU6050_ADDRESS 0x68 // MPU Address
#define MPU6050_RA_ACCEL_XOUT_H 0x3B
#define MPU6050_RA_ACCEL_XOUT_L 0x3C
#define MPU6050_RA_PWR_MGMT_1 0x6B

int16_t AcX;

void setup(){
  Wire.begin(); //  join the I2C bus as a master
  Wire.beginTransmission(MPU6050_ADDRESS); // begin transmission to MPU6050 (Slave)
  Wire.write(MPU6050_RA_PWR_MGMT_1); // queue the power management register address
  Wire.write(1); // queue the register value for the clock source to X-gyro (performs slightly better than the default 8 MHz)
  Wire.endTransmission(true); // transmits the addresses queued with Wire.write() and ends the transmission initiated by Wire.beginTransmission()
  Serial.begin(9600); // initiate a serial communication at 9600 bits/s
}
void loop(){
  Wire.beginTransmission(MPU6050_ADDRESS); // begin transmission to MPU6050 (Slave)
  Wire.write(MPU6050_RA_ACCEL_XOUT_H);  // queue the ACCEL_XOUT_H register
  Wire.endTransmission(false); // send the queued ACCEL_XOUT_H register and send repeated start the "writing to slave" transmission
  Wire.requestFrom(MPU6050_ADDRESS,2,true);  // request 2 bytes from the slave 
  AcX=Wire.read()<<8|Wire.read();  // combine data from both registers, the 0x3B (ACCEL_XOUT_H) & 0x3C (ACCEL_XOUT_L) into one 16-bit variable  
  Serial.print("AcX = "); Serial.println(AcX); // send the measurement via serial
  delay(10); // 10 ms delay
}
</code></pre>

<p>I will assume that you know the basics of C or Arduino dialect, so I won't go into details on how to include a library, such as Wire.h, how to declare a variable or what setup() and loop() functions are.</p>

<p><code>Wire.begin();</code> sets up the chip for the I2C communications and joins the I2C bus as a master. (If we wanted the Arduino to be as a slave device, we would pass a desired I2C address to the begin method.)</p>

<p><code>Wire.beginTransmission(MPU6050_ADDRESS);</code> does what is says, it begins the transmission with the slave device, in this case the MPU6050 with the address 0x68 as defined with the MPU6050_ADDRESS macro.</p>

<p>The following two lines: <code>Wire.write(MPU6050_RA_PWR_MGMT_1);</code> and <code>Wire.write(1);</code> queue ("store") the bytes to be sent to the slave device when <code>Wire.endTransmission(true)</code> is called. The input argument for the endTransmission method specifies whether to end the transmission with a <strong>Stop condition</strong> or a <strong>Repeated Start condition</strong>. The repeated start is used when we want to send a command to a device and then read the response right away. This keeps the I2C bus busy, so another master on the bus cannot interrupt the transmission. The MPU6050_RA_PWR_MGMT_1 register sets up the clock source that drives the IMU. I don't want to go into details here, I will write another post about the MPU6050. For now just remember that by setting the MPU6050_RA_PWR_MGMT_1 register to 0b00000000 (0) the MPU6050 will use its internal 8 MHz clock, by setting the register to 0b00000001 (1), it will use the X-gyroscopes clock, which was determined to be a bit more stable than the default clock. One very important thing to remember how Arduino's wire.h library works is that it queues the bytes we want to send and sends all of them when endTransmission method is called. A queue is a <strong>FIFO (First In First Out)</strong> data structure, which means that whatever we queue first, will be sent first. Let's show how this works on the code written inside the loop() function.</p>

<ol>
<li><code>Wire.beginTransmission(MPU6050_ADDRESS);</code>-queue the 7-bit MPU6050 address - 0b1101000</li>
<li><code>Wire.write(MPU6050_RA_ACCEL_XOUT_H);</code>-queue a 0 (write to slave) bit after the address and the register address byte we want to send to the slave</li>
<li><code>Wire.endTransmission(false);</code>-send the two bytes queue above and send a <strong>repeated start</strong> instead of a stop conditions, because we want to receive data from the slave</li>
<li><code>Wire.requestFrom(MPU6050_ADDRESS,2,true);</code>-send the 7-bit MPU6050 address, the 1 (read from slave) bit, and let prepare to prepare to read two bytes from the slave. This means that after the first byte is receive the master acknowledges (ACK) and not-acknowledges (NACK) after it receives the second byte. The third argument, "true", let's the master know that we want to stop the communication after we receive both bytes.</li>
<li><code>AcX=Wire.read()<<8|Wire.read();</code>-with the method <code>Wire.read()</code> we read each byte (8-bits) of the 16-bit accelerometer measurement separately and store it in a 16-bit variable AcX. Below is a detailed explanation of this line of code.</li>
</ol>

<p>The MPU6050 IMU uses a 16-bit <strong>analog-to-digital converted (ADC)</strong> for digitizing sensor outputs, so all the sensor readings are 16-bit signed integer values (two's complement format), but it stores the number in two 8-bit registers. The most significant byte (the high byte) is stored in one register, while the other, the least significant byte (the low byte) is stored in another register. For convenience, the MPU6050 (as well as most of other sensor devices) stores the high byte of the sensor measurement one register before the register that hold the low byte. For instance the X-Accelerometer high byte is stored in the register with the address 0x3B, while the low byte is stored at 0x3C, so by taking the advantage of ACK and NACK bits we can receive both bytes one after another. Line <code>AcX=Wire.read()<<8|Wire.read();</code> reads both, the high and the low byte one after another and does some bitwise operations to store them in the 16-bit variable AcX. These operations can be written in multiple lines of code for better clarity, such as:</p>

<pre class=".pre-scrollable"><code>
  AcX_High = Wire.read();
  AcX_Low = Wire.read();
  AcX = AcX_High<<8;
  AcX = AcX|AcX_Low;
</code></pre>

<p>Where the first line stores the high byte to AcX_High 16-bit signed variable (uint16_t), the second line does the same with the low byte and stores it to AcX_Low, the third line shifts the high_byte 8-bits to the left with the <strong>bit-shift operator</strong> (left: <<, right: >>), the fourth line performs the <strong>bitwise</strong> OR operation with the AcX variable containing the shifter high byte and the AcX_Low variable containing the low byte. The bitwise OR does the OR operation between each bit of each variable. Below is a graphical representation of these operations.</p>

<img src="images/I2C_bitOps.png" class="report-figure" style="width: 70%; padding-top: 10px; padding-bottom: 20px;">

<p>It's important to mention that the endTransmission method sends what is stored (queued) in a queue, it does not send all of the at once exactly, but it sends the next byte only if it received an acknowledgment (ACK) from the slave. To make sure that everything I wrote here is true, take a look at the output from the oscilloscope connected to the SDA and SCL while the above program was running.</p>

<img src="images/oscilloscope.jpg" class="report-figure" style="width: 90%; padding-top: 20px; padding-bottom: 20px;">

<p>ATmega328p and Raspberry Pi examples coming soon...</p>

<p>For any suggestions or improvements please feel free to contact me.</p>

<p>Author: alex.kraljic@gmail.com</p>

<!--</div>-->
	<hr>
      <footer>
        <p>&copy; 2017 Aleksij Kraljic <i class="fa fa-space-shuttle"></i></p>
      </footer>
    </div> <!-- /container -->
    <script src="myNavbar.js"></script>
</body>
</html>
