<!DOCTYPE html>
<html lang="en">
<head>
    <title>axkralj990</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="AK_stylesheet.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Orbitron">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto Condensed">
</head>
<body>

	<div id="myNav" class="tutorials"></div>

	<div class="container" style="margin-top: 70px;">

    <h1>I<sup>2</sup>C</h1>

<h3>Introduction</h3>
<p><strong>I<sup>2</sup>C</strong> (pronounced I-two-C and usually written as I2C) is a very popular communication protocol in the world of microcontrollers. It's advantage is that it allows communication between multiple devices by using only two wires, <strong>SDA (Serial Data Line)</strong> and <strong>SCL (Serial Clock Line)</strong>, unlike USART or SPI where every pair of devices needs its own set of wires. The protocol was invented by Phillips Semiconductors in 1982. The first time I encountered I2C was when I wanted to obtain the orientation in space with my Arduino. For that purpose I bought an MPU6050 inertial measurement unit (IMU) that required I2C to get the sensor readings from it. At first I was really confused since I had no experience with digital communication protocols except some basic understanding of the Arduino's Serial library. The first time I saw an example code for reading accelerometer and gyroscope data from the MPU6050, it scared the hell out of me with of a bunch of hexadecimal register addresses. In this tutorial I will try to do my best to explain the principle of the I2C protocol and show an example using an Arduino, a standalone ATmega328P chip and a Raspberry Pi. I will start with an Arduino Uno and add examples with other devices later. I will use the MPU6050 IMU in my examples, but you may use whichever device you desire. Sometimes I will refer to the Arduino and the standalone ATmega328P chip, simply as ATmega328P, since this is also the processor that the Arduino uses, but I will also provide an example on how to use I2C on a standalone ATmega328P chip in plain C. On a side note, in terms of legal issues, I<sup>2</sup>C can be freely implemented on any commercial device, but in order to use the name I<sup>2</sup>C on the product, you have to pay some money to NXP Semiconductor. For this reason, some of the products use a different name, for instance Atmel uses "Two-wire interface" (TWI) on their chips (ATmega328P).</p>

<h3>The Principle</h3>

<p>To explain how the protocol works I will use an example with three human slaves, where each one of them monitors a different sensor and reports the reading to the one of the two masters when they request it. Slaves and masters use walkie-talkies to talk to each other. Image below shows the three slaves and two masters.</p>

<img src="images/master_slave.png" class="report-figure" style="width: 30%; padding-bottom: 25px;">

<p>Slave A monitors a humidity sensor, slave B a thermometer and slave C a barometer. Masters 1 or 2 can ask the slaves for readings whenever they want. In smaller microcontroller projects, you will most likely use a single master, but in order to explain the full functionality of I2C, I'm using two masters.</p> 

<p>Since there are three different slaves, each one of them has a name (an address) by which a master gets their attention. To keep it simple I will just name them A, B an C, as depicted on the image. They agreed in advance that to get the data from the slaves, a master has to first remotely ring a bell at the site where the slaves are, get the desired slave's attention by calling the slave's name and then tell the slave in what units the data should be reported. Once the master gets a pencil and a paper to write down the measurement from the slave he/she transmits the name of the slave again, which means that the slave should report the measurement. Once the measurement is written down, the master rings the bell twice to mark the end of the conversation. Another important purpose of the bell is to let the other master know, that he/she should wait until the first master ends the conversation. To make sure that a certain slave is present (better be) and that the instruction was heard, the receiver <strong>acknowledges</strong> that the instruction was received. If the master is happy with the received message, he/she transmits "enough", to indicate that this was all that was needed. I will call this "enough" as not-acknowledged (sounds weird, but you will see later why I call it like that). In order for the master 1 to receive the temperature in Fahrenheit from the slave B, the conversation would go as following:</p>

<table class="table" style="width: 80%; margin: 0 auto;">
    <thead>
      <tr>
        <th>Message Type</th>
        <th>Person</th>
        <th>Message</th>
      </tr>
    </thead>
    <tbody>     
      <tr class="success">
        <td>Start Condition</td>
        <td>Master 1:</td>
        <td><i class="fa fa-bell" aria-hidden="true"></i></td>
      </tr>
      <tr class="success">
        <td>Slave Address</td>
        <td>Master 1:</td>
        <td>"slave B listen"</td>
      </tr>
      <tr class="info">
        <td>Slave's Acknowledgment</td>
        <td>Slave B:</td>
        <td>"roger"</td>
      </tr>
      <tr class="success">
        <td>Slave Instruction</td>
        <td>Master 1:</td>
        <td>"report temperature in F"</td>
      </tr>
      <tr class="info">
        <td>Slave's Acknowledgment</td>
        <td>Slave B:</td>
        <td>"roger"</td>
      </tr>
      <tr class="success">
        <td>Slave Address</td>
        <td>Master 1:</td>
        <td>"slave B go ahead"</td>
      </tr>
      <tr class="info">
        <td>Slave's Acknowledgment</td>
        <td>Slave B:</td>
        <td>"roger"</td>
      </tr>
      <tr class="info">
        <td>Slave Report</td>
        <td>Slave B:</td>
        <td>"95"</td>
      </tr>
      <tr class="success">
        <td>Master's Not-acknowledgment</td>
        <td>Master 1:</td>
        <td>"enough"</td>
      </tr>
      <tr class="success">
        <td>Stop Condition</td>
        <td>Master 1:</td>
        <td><i class="fa fa-bell" aria-hidden="true"></i><i class="fa fa-bell" aria-hidden="true"></i></td>
      </tr>
    </tbody>
  </table>

<p style="padding-top: 20px">Just to understand another important concept let's assume that the master 1 wants to know the pressure in psi and MPa from the slave C. They also agreed in advance that whenever the master acknowledges the reception by "roger", the slave then transmits the measurement in another unit right after. Slave C keeps track of pressure measurements in psi, MPa, atm and torr, so if the master received the measurement in psi, he/she acknowledges the message by "roger", to let the slave know to send the pressure in kPa as well. The slave keeps sending the measurement until the master "not-acknowledges" the reception by "enough" or until the slave has no more measurements to send. The conversation for receiving pressure measurements in psi and kPa would go like this:</p>

<table class="table" style="width: 80%; margin: 0 auto;">
    <thead>
      <tr>
        <th>Message Type</th>
        <th>Person</th>
        <th>Message</th>
      </tr>
    </thead>
    <tbody>     
      <tr class="success">
        <td>Start Condition</td>
        <td>Master 1:</td>
        <td><i class="fa fa-bell" aria-hidden="true"></i></td>
      </tr>
      <tr class="success">
        <td>Slave Address</td>
        <td>Master 1:</td>
        <td>"slave C listen"</td>
      </tr>
      <tr class="info">
        <td>Slave's Acknowledgment</td>
        <td>Slave C:</td>
        <td>"roger"</td>
      </tr>
      <tr class="success">
        <td>Slave Instruction</td>
        <td>Master 1:</td>
        <td>"report pressure in psi"</td>
      </tr>
      <tr class="info">
        <td>Slave's Acknowledgment</td>
        <td>Slave C:</td>
        <td>"roger"</td>
      </tr>
      <tr class="success">
        <td>Slave Address</td>
        <td>Master 1:</td>
        <td>"slave C go ahead"</td>
      </tr>
      <tr class="info">
        <td>Slave's Acknowledgment</td>
        <td>Slave C:</td>
        <td>"roger"</td>
      </tr>
      <tr class="info">
        <td>Slave Report</td>
        <td>Slave C:</td>
        <td>"14.7"</td>
      </tr>
      <tr class="success">
        <td>Master's Acknowledgment</td>
        <td>Master 1:</td>
        <td>"roger"</td>
      </tr>
      <tr class="info">
        <td>Slave Report</td>
        <td>Slave C:</td>
        <td>"1013.5"</td>
      </tr>
      <tr class="success">
        <td>Master's Not-acknowledgment</td>
        <td>Master 1:</td>
        <td>"enough"</td>
      </tr>
      <tr class="success">
        <td>Stop Condition</td>
        <td>Master 1:</td>
        <td><i class="fa fa-bell" aria-hidden="true"></i><i class="fa fa-bell" aria-hidden="true"></i></td>
      </tr>
    </tbody>
  </table>

<p style="padding-top: 20px">This acknowledgment, not-acknowledgment agreement would prove more useful if there was only one slave that was measuring all the different sensors at once. In that case the master would just tell the slave to report whatever measurement was the first on the list and keep acknowledging until all the required measurements were received. The communications seems quite complicated and redundant, but this protocol is not really intended for humans, but digital devices instead. By saying that they know something in <strong>advance</strong>", it implies that these are the <strong>rules</strong> of the protocol. Before going into the world of digital devices, let's go over some of the specifications and prerequisites.</p>

<h3>The Basics</h3>

<p>In order to follow the tutorial you should be familiar with:</p>
<ul>
  <li>basic electronics</li>
  <li>basic C (or Arduino dialect)</li>
  <li>the difference between binary, decimal, hexadecimal, ...</li>
  <li>what registers are (at least know that a register is a memory slot where data or instructions are stored, in ATmega328P a register can hold 8 bits (1 byte)).
</li>
</ul>

<p>The devices communicating via I2C are all connected to the same set of wires, SDA (Serial Data Line) and SCL (Serial Clock Line). The two wires constitute the <strong>I2C bus</strong>. As shown in the example above, I2C is a <strong>multi-master</strong>, <strong>multi-slave protocol</strong>, which means that a system of nodes (devices) can have multiple master devices and multiple slave devices. To understand what this means you need to understand what each one of them does. In a few words:</p>

<ul>
	<li>Master Device: generates the clock and initializes the communication with a slave device</li>
	<li>Slave Device: receives the clock and responds when addressed by the master.</li>
</ul>

<p>Microcontrollers such as the Arduino (ATmega328P) can be configured to act as a master or a slave device, whereas simpler sensor devices usually support only the slave mode.</p>

<blockquote><small>One thing to keep in mind when using multiple masters is that they cannot communicate with each other, but they have to listen to the I2C bus if anyone else is transmitting before requesting data from the slaves, so they don't request it at the same time, otherwise the slaves would not understand what masters want. This also applies to the regular conversation between people. If you talked to an audience, everyone who listened would understand what you are saying (assuming you talked loud and clear in a language everyone understood). But if everyone in the audience tried to tell you something at the same time, you would just hear some jibber jabber. If two or more masters transmit a packet to slaves at the same time, the packets <em>collide</em>, so in case of a multi-master I2C setup, a some sort of packet collision avoidance mechanism has to be implemented. As I wrote before, this only applies if you have a project consisting of multiple master devices, otherwise do not worry about this for now.</small></blockquote>

<h4>SCL and SDA</h4>

<p><strong>SDA</strong> is where the data, the payload, is transmitted between the devices.</p>

<p><strong>SCL</strong> is where the master sends the generated clock signal that the slave devices receive. With this said, a shared clock between the master and slave devices makes I2C a <strong>synchronous protocol</strong>, in contrast of UART, which is <strong>asynchronous</strong>. In asynchronous protocols the two devices talking to each other need to know in advance the rate at which they will transfer the bits (baudrate).</p>

<p><strong>The clock</strong> that the master generates defines the rate at which the data is transfered. I2C supports various clock speeds, but simple devices commonly used in microcontroller projects support the original 100 kHz mode or the 400 kHz fast-mode. The fastest supported mode for I2C right now is the 5 GHz Ultra Fast-mode.</p>

<h4>Addressing</h4>

<p>The number of devices that I2C can communicate with is defined by the number of bits each device's address consists of. I2C devices can have 7 or 10 bit addresses. In theory, the largest number that a 7-bit address can be is (1111111)<sub>2</sub> or (127)<sub>10</sub>, which defines the maximum number of devices connected to the same I2C bus. Since there are some addresses that are reserved and cannot be used for addressing, the maximum number of devices with 7-bit addresses is (112)<sub>10</sub>. (I am using the parentheses with a subscript to indicate the base of the number, so 2 for binary and 10 for decimal and 16 for hexadecimal.) The maximum number of devices is also limited at the physical layer by the total bus capacitance.</p>

<p>I2C and any other memory addresses (registers, etc.) are by convention expressed in hexadecimal. Hexadecimal numbers are much more convenient then binary, since in binary the addresses would become very long, which would be hard to remember and prone to mistakes. The conversion between hexadecimal and binary is much easier then between decimal and binary. Sometimes I will use the C-language syntax to indicate the base of the numbers, where decimal numbers are depicted simply as the number itself, binary numbers have a 0b prefix (ex: 0b1010 = 10) and hexadecimals have a 0x prefix (ex: 0xA = 0b1010 = 10).</p>

<h3>Example with Digital Devices</h3>

<p>To give more sense to what I just explained, let's consider a real I2C example shown below.</p>

<img src="images/master_slave_real.png" class="report-figure" style="width: 65%; padding-bottom: 20px;">

<p>This setup uses two masters, one is an Arduino Uno used to control something and the other one is a Raspberry Pi used for storing the data to a remote database. The slaves are two MPU6050 IMUs, placed on two different spots on, for example, on a spaceship.</p>

<p>As we switched from people to digital devices, the first thing to do is to wire them properly. As you can see on the image above, both I2C wires, SDA and SCL are connected to the same voltage source by 2 pull-up resistors. The reason the pull-up resistors are used is that the I2C lines are <strong>open-drain</strong> (or <strong>open-collector</strong> in TTL), which means that the signal can be pulled to low, but not to high. For projects with Arduino, Raspberry Pi and other similar devices, the voltage source is usually at 3.3 V or 5 V. The selection of pull-up resistors is a bit more complicated, since an optimal resistance depends on the length of the wires and the number of devices connected to the bus. Sparkfun recommends to start with 4.7 k&#8486; resistors and work down if needed. All of the devices have to be connected to a common ground, this is very important. Before getting all confused by selecting proper pull-up resistors make sure that the devices you are going to use don't implement them already, for instance MPU6050 has both lines connected to high with 4.7 k&#8486; resistors. Having all the devices close to each other should work well most of the time, but if you intend to use longer wires between the devices, you might have to try different pull-up resistors. Also keep in mind that long wires are more prone to noise-induced errors, so if there is a lot of noise in the environment, the wires should be kept as short as possible.</p>

<p>Now that all is hooked up, let's go into the basics of the protocol. The clock signal on the SCL is generated by the master devices when it initiates the communication. When no communication is taking place, the SCL is constantly pulled to high. A very important rule of the protocol is that a signal on the SDA can change only when the clock is low, the only exception to this is when the master signals the start or the stop of the communication. Start and stop conditions consist of a change of state when the clock is high, they are defined as:</p>

<ul>
	<li>Start: SDA is pulled from high to low</li>
	<li>Stop: SDA is pulled low from high.</li>
</ul>

<p>Right after the start condition is transmitted by the master, other communication information follow. Devices decode whether the bit sent is true or false, by checking if the voltage is high or low when the clock (SCL) is high. It's easier to explain this with a simple timing diagram as shown below: (For drawing timing diagrams I use <a href="http://wavedrom.com/" target="_blank">WaveDorm</a>.)</p>

<img src="images/I2C_timing.png" class="report-figure" style="width: 70%">

<p>In this example I will use devices with 7-bit addresses, slave A has the address (68)<sub>16</sub> and slave B the address (69)<sub>16</sub>. In order to address the right slave, its address has to be sent in binary right after the start bit. For example, to address the (68)<sub>16</sub> MPU6050, (1101000)<sub>2</sub> has to be sent.</p>

<p>Just like the master had to tell the slave whether to listen or to report the data, the master device has to do the same by sending another specific bit after the address. This bit is called the <strong>direction bit</strong> (READ/WRITE), where:</p>

<ul>
  <li>Read: 1 (low)</li>
  <li>Write: 0 (high)</li>
</ul>

<p>Sometimes the addresses are written as the <strong>write</strong> and <strong>read address</strong>. Those addresses are just the 7-bit device's address with the direction bit appended. Arduino's "Wire.h" library takes care of that for you, so you don't have to worry about it, but you might run into it at some point. For the (68)<sub>16</sub> MPU6050 we could write read and write addresses as following:</p>

<ul>
  <li>Read Address: (11010001)<sub>2</sub> = (D1)<sub>16</sub></li>
  <li>Write Address: (11010000)<sub>2</sub> = (D0)<sub>16</sub></li>
</ul>

<p>When the slave is addressed and no errors occurred, it acknowledges the message. The acknowledge bit is usually written as <strong>ACK</strong> and not-acknowledge as <strong>NACK</strong>, where:</p>

<ul>
  <li>ACK: 0 (low)</li>
  <li>NACK: 1 (high)</li>
</ul>

<p>ACK or NACK bit is transmitted by the received device, whether the received is a master or the slave. It is transmitted right after the 8 bits from the sender are received. NACK bit is used to let the sender know that enough information was received and that the communication is about to stop or if an error occurred, so it can be used for error checking as well. This also makes I2C suitable for noisy environments.</p>

<p>To recap how the whole communication between a master and a slave goes, I will show it in a similar table I used in the second example, except here I will use an IMU for getting the 16-bit signed integer reading of the acceleration in X direction (the coordinate axis is drawn on the accelerometer). Because only 8-bit number can be read from a device and because the IMU (as well as the ATmega328P) store the data in 8-bit registers, 16-bit numbers have to be stored in two separate registers. The most significant byte is stored at one location and the least significant byte at another location in memory, most of the time they are in the next location from the most significant bit, so they can be read one after another. Here is the table:</p>

<table class="table" style="width: 80%; margin: 0 auto;">
    <thead>
      <tr>
        <th>Message Type</th>
        <th>Device</th>
        <th>Verbal</th>
        <th>Digital</th>
      </tr>
    </thead>
    <tbody>     
      <tr class="success">
        <td>Start Condition</td>
        <td>Master 1:</td>
        <td><i class="fa fa-bell" aria-hidden="true"></i></td>
        <td>SDA <i class="fa fa-arrow-down" aria-hidden="true"></i></td>
      </tr>
      <tr class="success">
        <td>Slave Address</td>
        <td>Master 1:</td>
        <td>"slave C listen"</td>
        <td>(11010000)<sub>2</sub> <i class="fa fa-arrow-right" aria-hidden="true"></i> Slave Write Address</td>
      </tr>
      <tr class="info">
        <td>Slave's Acknowledgment</td>
        <td>Slave C:</td>
        <td>"roger"</td>
        <td>ACK <i class="fa fa-arrow-right" aria-hidden="true"></i> 0</td>
      </tr>
      <tr class="success">
        <td>Slave Instruction</td>
        <td>Master 1:</td>
        <td>"report X-accelerationX (High Byte)"</td>
        <td>(XXXXXXXX)<sub>2</sub> <i class="fa fa-arrow-right" aria-hidden="true"></i> Register to get the data from</td>
      </tr>
      <tr class="info">
        <td>Slave's Acknowledgment</td>
        <td>Slave C:</td>
        <td>"roger"</td>
        <td>ACK <i class="fa fa-arrow-right" aria-hidden="true"></i> 0</td>
      </tr>
      <tr class="success">
        <td>Slave Address</td>
        <td>Master 1:</td>
        <td>"slave C go ahead"</td>
        <td>(11010001)<sub>2</sub> <i class="fa fa-arrow-right" aria-hidden="true"></i> Slave Read Address</td>
      </tr>
      <tr class="info">
        <td>Slave's Acknowledgment</td>
        <td>Slave C:</td>
        <td>"roger"</td>
        <td>ACK <i class="fa fa-arrow-right" aria-hidden="true"></i> 0</td>
      </tr>
      <tr class="info">
        <td>Slave Report</td>
        <td>Slave C:</td>
        <td>"14.7"</td>
        <td>(XXXXXXXX)<sub>2</sub> <i class="fa fa-arrow-right" aria-hidden="true"></i> 8-bit data value</td>
      </tr>
      <tr class="success">
        <td>Master's Acknowledgment</td>
        <td>Master 1:</td>
        <td>"roger"</td>
        <td>ACK <i class="fa fa-arrow-right" aria-hidden="true"></i> 0</td>
      </tr>
      <tr class="info">
        <td>Slave Report</td>
        <td>Slave C:</td>
        <td>"1013.5"</td>
        <td>(XXXXXXXX)<sub>2</sub> <i class="fa fa-arrow-right" aria-hidden="true"></i> 8-bit data value</td>
      </tr>
      <tr class="success">
        <td>Master's Not-acknowledgment</td>
        <td>Master 1:</td>
        <td>"enough"</td>
        <td>NACK <i class="fa fa-arrow-right" aria-hidden="true"></i> 1</td>
      </tr>
      <tr class="success">
        <td>Stop Condition</td>
        <td>Master 1:</td>
        <td><i class="fa fa-bell" aria-hidden="true"></i><i class="fa fa-bell" aria-hidden="true"></i></td>
        <td>SDA <i class="fa fa-arrow-up" aria-hidden="true"></i></td>
      </tr>
    </tbody>
  </table>

<p>Now let's do some examples with the real hardware. I recommend you to go through all of the examples (as of now, Arduino and Raspberry Pi), since you will most likely learn different things related to I2C in general from each example. In the first example, with the Arduino Uno, I will also show the oscilloscope output and analyze it.</p>
		
<h3>Arduino Example</h3>

<p>For this example I will use the MPU6050 IMU as well, since this is a chip I work most often with and I think it's simple enough to use it for introductory I2C example. The MPU6050 operates on 3.3 V, but the board has a voltage regulator, so it will work by connecting it to 5 V as well. The schematic for this example is shown below:</p>

<img src="images/arduinoExample.png" class="report-figure" style="width: 30%; padding-top: 20px; padding-bottom: 20px;">

<p>The Vcc pin on the MPU6050 is connected to 5 V on the Arduino. Grounds (GND) are connected together. SCL and SDA pins on the MPU6050 are connected to SCL and SDA on the Arduino, SCL is connected to pin A5 and SDA is to pin A4. AD0 pin on the MPU6050 is connected to the ground, the AD0 pin is the  "device address select" pin, since if connected to the ground, MPU6050's address is (68)<sub>16</sub>, if connected to Vcc, its address is (69)<sub>16</sub>. This makes it possible to use two MPU6050s on the same I2C bus.</p>

<p>With the MPU6050 we can measure acceleration and angular rates in three axis (X, Y and Z), but for simplicity I will read only acceleration in the X direction. All of the measurements on the IMU are 16 bits longs, hence they are stored in two separate registers that have to be read separately and combined into one 16-bit variable on the Arduino.</p>

<p>In the example with the ATmega328P I will go more into lower level details on how I2C works, but in this example with the Arduino Uno, I will keep it a bit simpler and I will use Arduino's "Wire.h" library that is written specifically for I2C communication. First I will show the code and then explain it.</p>

<pre class=".pre-scrollable"><code>
#include&lt;Wire.h&gt;

#define MPU6050_ADDRESS 0x68 // MPU Address
#define MPU6050_RA_ACCEL_XOUT_H 0x3B
#define MPU6050_RA_ACCEL_XOUT_L 0x3C
#define MPU6050_RA_PWR_MGMT_1 0x6B

int16_t AcX;

void setup(){
  Wire.begin(); //  join the I2C bus as a master
  Wire.beginTransmission(MPU6050_ADDRESS); // begin transmission to MPU6050 (Slave)
  Wire.write(MPU6050_RA_PWR_MGMT_1); // queue the power management register address
  Wire.write(1); // queue the register value for the clock source to X-gyro (performs slightly better than the default 8 MHz)
  Wire.endTransmission(true); // transmits the addresses queued with Wire.write() and ends the transmission initiated by Wire.beginTransmission()
  Serial.begin(9600); // initiate a serial communication at 9600 bits/s
}
void loop(){
  Wire.beginTransmission(MPU6050_ADDRESS); // begin transmission to MPU6050 (Slave)
  Wire.write(MPU6050_RA_ACCEL_XOUT_H);  // queue the ACCEL_XOUT_H register
  Wire.endTransmission(false); // send the queued ACCEL_XOUT_H register and send repeated start the "writing to slave" transmission
  Wire.requestFrom(MPU6050_ADDRESS,2,true);  // request 2 bytes from the slave 
  AcX=Wire.read()<<8|Wire.read();  // combine data from both registers, the 0x3B (ACCEL_XOUT_H) & 0x3C (ACCEL_XOUT_L) into one 16-bit variable  
  Serial.print("AcX = "); Serial.println(AcX); // send the measurement via serial
  delay(10); // 10 ms delay
}
</code></pre>

<p>I will assume that you know the basics of C or Arduino dialect, so I won't go into details on how to include a library, how to declare a variable or what setup() and loop() functions are.</p>

<p><code>Wire.begin();</code> sets up the chip for the I2C communications and joins the I2C bus as a master. (If we wanted the Arduino to be as a slave device, we would pass a desired I2C address to the begin method.)</p>

<p><code>Wire.beginTransmission(MPU6050_ADDRESS);</code> does what is says, it begins the transmission with the slave device, in this case the MPU6050 with the address 0x68 as defined with the MPU6050_ADDRESS macro.</p>

<p>The following two lines: <code>Wire.write(MPU6050_RA_PWR_MGMT_1);</code> and <code>Wire.write(1);</code> queue ("store") the bytes to be sent to the slave device when <code>Wire.endTransmission(true)</code> is called. The input argument for the endTransmission method specifies whether to end the transmission with a <strong>Stop condition</strong> or a <strong>Repeated Start condition</strong>. The repeated start is used when we want to send a command to a device and then read the response right away. This keeps the I2C bus busy, so another master on the bus cannot interrupt the transmission. The MPU6050_RA_PWR_MGMT_1 register sets up the clock source that drives the IMU. I don't want to go into details here, I will write another post about the MPU6050. For now just remember that by setting the MPU6050_RA_PWR_MGMT_1 register to 0b00000000 (0) the MPU6050 will use its internal 8 MHz clock, by setting the register to 0b00000001 (1), it will use the X-gyroscopes clock, which was determined to be a bit more stable than the default clock. An important thing to remember about how Arduino's "Wire.h" library works is that it <strong>queues</strong> the bytes we want to send and sends all of them when endTransmission method is called. A <strong>queue</strong> is a <strong>FIFO (First In First Out)</strong> data structure, which means that whatever we queue first, will be sent first. Let's show how this works by going through the code written inside the loop() function.</p>

<ol>
<li><code>Wire.beginTransmission(MPU6050_ADDRESS);</code>-queue the 7-bit MPU6050 address - 0b1101000</li>
<li><code>Wire.write(MPU6050_RA_ACCEL_XOUT_H);</code>-queue a 0 (write to slave) bit after the address and the register address byte we want to send to the slave</li>
<li><code>Wire.endTransmission(false);</code>-send the two bytes queue above and send a <strong>repeated start</strong> instead of a stop conditions, because we want to receive data from the slave</li>
<li><code>Wire.requestFrom(MPU6050_ADDRESS,2,true);</code>-send the 7-bit MPU6050 address, the 1 (read from slave) bit, and let prepare to prepare to read two bytes from the slave. This means that after the first byte is receive the master acknowledges (ACK) and not-acknowledges (NACK) after it receives the second byte. The third argument, "true", let's the master know that we want to stop the communication after we receive both bytes.</li>
<li><code>AcX=Wire.read()<<8|Wire.read();</code>-with the method <code>Wire.read()</code> we read each byte (8-bits) of the 16-bit accelerometer measurement separately and store it in a 16-bit variable AcX. Below is a detailed explanation of this line of code.</li>
</ol>

<p>The MPU6050 IMU uses a 16-bit <strong>analog-to-digital converter (ADC)</strong> for digitizing sensor outputs, so all the sensor readings are 16-bit signed integer values (two's complement format), but it stores the number in two 8-bit registers. The most significant byte (the high byte) is stored in one register, while the other, the least significant byte (the low byte) is stored in another register. For convenience, the MPU6050 (as well as most of the other sensor devices) holds the high byte of the sensor measurement one register before the register that holds the low byte. For instance the X-Accelerometer high byte is stored at the address 0x3B, while the low byte is stored at 0x3C, so by taking the advantage of the ACK and NACK bits we can receive both bytes one after another. Line <code>AcX=Wire.read()<<8|Wire.read();</code> reads both, the high and the low byte one after another and does some bitwise operations to store them in the 16-bit variable AcX. These operations can be also written in multiple lines of code for better clarity, such as:</p>

<pre class=".pre-scrollable"><code>
  AcX_High = Wire.read();
  AcX_Low = Wire.read();
  AcX = AcX_High<<8;
  AcX = AcX|AcX_Low;
</code></pre>

<p>The first line stores the high byte to AcX_High 16-bit signed variable (int16_t), the second line does the same with the low byte and stores it to AcX_Low, the third line shifts the high byte 8-bits to the left with the <strong>bit-shift operator</strong> (left: <<, right: >>), the fourth line performs the <strong>bitwise</strong> OR operation with the AcX variable containing the shifted high byte and the AcX_Low variable containing the low byte. The bitwise OR does the OR operation between each bit. Below is a graphical representation of these operations.</p>

<img src="images/I2C_bitOps.PNG" class="report-figure" style="width: 50%; padding-top: 10px; padding-bottom: 20px;">

<p>It's important to mention that the endTransmission method sends what is stored (queued) in a queue, it does not send all of it at once, but it sends the next byte only if it received an acknowledgment (ACK) from the slave. To make sure that everything I wrote here is true, take a look at the output from the oscilloscope connected to the SDA and SCL while the above program was running. I will leave it to you to make sense of the oscilloscope output.</p>

<img src="images/oscilloscope.jpg" class="report-figure" style="width: 70%; padding-top: 20px; padding-bottom: 20px;">

<h3>Raspberry Pi Example</h3>

<p>On Raspberry Pi you can use I2C with a language of your choice (Python, C, C++, Java, etc.), but here I will show an example with Python, since I think this is a good place to start. If you feel like using another language, then a solid understanting of the principle of I2C should be enough to figure out the rest.</p>

<p>I will assume you are using Raspberry Pi 3 with the Raspbian operating system and have python 2 or 3 already installed. To follow this install the following two packages:</p>

<pre class=".pre-scrollable"><code>
sudo apt-get install -y python-smbus
sudo apt-get install -y i2c-tools
sudo apt-get install build-essential libi2c-dev i2c-tools python-dev libffi-dev
</code>
</pre>

<p>SMBus (System Management Bus) is a two-wire protocol that can be thought of as a subset of I2C and is very common in computer motherboards. The principle is pretty much the same as in I2C, but there are some differencies that should be considered. I will not go into detail here, but you should familiarize yourself if you will be working on a project, where I2C and SMBus devices will be sharing the same bus. For more information consider <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/Documentation/i2c/smbus-protocol">SMBus documentation</a></p>

<p>After all the packages have installed correctly, you have to enable I2C interface by typing <code>raspi-config</code>, then going to <strong>Interfacing Options</strong>, where you can enable I2C. More on configuring I2C can be found on <a href="https://learn.adafruit.com/adafruits-raspberry-pi-lesson-4-gpio-setup/configuring-i2c">Adafruit</a> and at <a href="https://learn.sparkfun.com/tutorials/raspberry-pi-spi-and-i2c-tutorial">Sparkfun</a>.</p>

<p>To hook the MPU6050 to Raspberry Pi you can reference the following diagram:</p>

<img src="images/RPi_MPU6050.png" class="report-figure" style="width: 50%; padding-top: 20px; padding-bottom: 20px;">

<p>As you can see on the gpio diagram above, you need to hook SDA from MPU6050 to pin 3 and SCL to pin 5. Ground can be connected to any of the <strong>GND</strong> pins. You can power the MPU6050 from any of the 3.3 V or 5 V gpio pins on the Pi, since the MPU6050 converts the input voltage to 3.3 V, but since the chip runs on 3.3 V you might as well use this voltage.</p>

<p>Now that all the packages are installed and everything is hooked up, lets see if the RPi detects the MPU6050 by running the command <code>i2cdetect -y 1</code>. The output of the command should look similar to this:</p>

<pre class=".pre-scrollable"><code>
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- --
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
60: -- -- -- -- -- -- -- -- 68 -- -- -- -- -- -- --
70: -- -- -- -- -- -- -- --
</code>
</pre>

<p>where you can see all the devices that were detected on the bus. You can see that in my case it detected a device with an address 68, which corresponds to the MPU6050.</p>
  
<p>Start off by creating a python file, I will name my i2cTutorial.py. Just like in the example with the arduino, I will show you the code first and then go through it line by line, so here it is:</p>

<pre class=".pre-scrollable"><code>
import smbus
import time

bus = smbus.SMBus(1) # set 1 for /dev/i2c-1 I2C1

DEVICE_ADDRESS = 0x68 # MPU6050 7-bit address
PWR_MGMT_1 = 0x6B # power management register address
ACCEL_XOUT_H = 0x3B # accelerometer high byte register address

# Write a single register to set to clock source to X-gyro
bus.write_byte_data(DEVICE_ADDRESS, PWR_MGMT_1, 1)

while True:
    receivedBlock = bus.read_i2c_block_data(DEVICE_ADDRESS, ACCEL_XOUT_H, 2)

    if receivedBlock[0] > 127:
    	receivedBlock[0] = (256-receivedBlock[0])*(-1)

    accelX = (receivedBlock[0]<<8)|receivedBlock[1]

    print("AcX = " + accelX)
    time.sleep(0.01)
</code>
</pre>

<p>Before going into the code description, I briefly explain I2C-0 and I2C-1 on the 40-pin Raspberry Pi gpio pins. If you look at the pinout digram above, you will see that pins 3 and 5 are SDA1 and SCL1 respectivelly. The number 1 at the end means that these two line consist the I2C-1 bus, which is the one used in this example. If you look at pins 27 and 28, you will notice that these two are also I2C data and clock lines, except that these two are specifically used for talkin to EEPROM chips and nothing else (unless you reconfigure you Pi). It is commonly used to initialize Raspberry Pi hats at startup. I will show you shortly why this information is important. More info on this can be found <a  href="https://learn.sparkfun.com/tutorials/raspberry-pi-spi-and-i2c-tutorial/i2c-0-on-40-pin-pi-boards">here</a>.</p>

<p>The first two lines of the code <code>import smbus</code> and <code>import time</code> are used to import the smbus module and time module, which is just add some delay in the loop that reads and prints the data to the terminal. Next we have to create a <strong>bus object</strong> from the smbus class: <code>bus = smbus.SMBus(1)</code>. The argument <strong>1</strong> means that we will be using the I2C-1 as described in the previous paragraph. Following 3 lines are just variables containig the MPU6050 7-bit address, the power management 1 register address and the high byte of the accelerometer reading address. Just like with the example with the Arduino we will set the clock source of the MPU6050 to X-gyro by writing a single byte, a number 1<sub>10</sub>, or 0b00000001 to the power management 1 register with the method <code>bus.write_byte_data(DEVICE_ADDRESS, PWR_MGMT_1, 1)</code></p>

<p>After this I created an infinite while loop, so to terminite the program you will have to press <strong>ctr+c</strong>. In each loop iteration we will read 2 bytes from the MPU6050, the high and the low byte of the acceleration in the X-direction with the method <code>receivedBlock = bus.read_i2c_block_data(DEVICE_ADDRESS, ACCEL_XOUT_H, 2)</code>. The <code>read_i2c_block_data()</code> method return an array with as many element as the bytes that it read, so in the next step we will have to do some bit twidling just like we did in the Arduino example above in order to get a 16-bit signed integer value of the reading. -></p>

<p>ATmega328p coming soon...</p>

<p>For any suggestions or improvements please feel free to contact me.</p>

<p>Author: alex.kraljic@gmail.com</p>

<!--</div>-->
	<hr>
      <footer>
        <p>&copy; 2017 Aleksij Kraljic <i class="fa fa-space-shuttle"></i></p>
      </footer>
    </div> <!-- /container -->
    <script src="myNavbar.js"></script>
</body>
</html>
